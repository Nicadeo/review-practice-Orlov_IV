# Сравнение эффективности линейного и бинарного поиска

## Задание 1: Измерение времени выполнения

### Результаты:

| Алгоритм         | Реальное время (ms) | Использование памяти (MiB) |
|------------------|---------------------|----------------------------|
| Линейный поиск   | ~100-500            | ~10-20                     |
| Бинарный поиск   | ~0.1-1              | ~10-20                     |

### Примечание:
- Линейный поиск имеет временную сложность O(n), что делает его медленным для больших массивов.
- Бинарный поиск имеет временную сложность O(log n), что значительно быстрее для отсортированных данных.

---

## Задание 2: Измерение использования памяти

### Результаты:
- Оба алгоритма используют примерно одинаковое количество памяти (~10-20 MiB), так как они работают с исходным массивом и не создают дополнительных структур данных.

---

## Задание 3: Анализ результатов

1. **Скорость работы**:
   - Бинарный поиск работает быстрее на больших данных благодаря его логарифмической сложности O(log n). Например, для массива из 10 000 000 элементов бинарный поиск выполняется за ~20 шагов, тогда как линейный поиск может потребовать до 10 000 000 шагов.

2. **Использование памяти**:
   - Оба алгоритма используют примерно одинаковое количество памяти, так как они не требуют дополнительных структур данных. Основная память расходуется на хранение массива.

3. **Ограничения инструментов**:
   - `time` (Linux/MacOS) и `Measure-Command` (Windows) предоставляют общее время выполнения, но не учитывают время загрузки интерпретатора Python.
   - `memory_profiler` добавляет накладные расходы на выполнение кода, что может искажать результаты замеров памяти. Для точных измерений лучше использовать специализированные инструменты, такие как `valgrind` или `tracemalloc`.

---

## Вывод:
- **Бинарный поиск** предпочтителен для больших отсортированных массивов из-за его скорости.
- **Линейный поиск** может быть полезен для небольших или неотсортированных данных, где накладные расходы на сортировку не оправданы.
- Оба алгоритма имеют схожее использование памяти, но выбор зависит от требований к скорости и условиям задачи.